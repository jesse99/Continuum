// Machine generated by peg-sharp 0.3.408.0 from source/plugins/debugger/expressions/ExpressionParser.peg.
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.Serialization;
using System.Security.Permissions;

namespace Debugger
{
	[Serializable]
	internal sealed class ParserException : Exception
	{
		public ParserException()
		{
		}
		
		public ParserException(string message) : base(message)
		{
		}
		
		public ParserException(int line, int col, string file, string message) : base(string.Format("{0} at line {1} col {2}{3}", message, line, col, file != null ? (" in " + file) : "."))
		{
		}
		
		public ParserException(int line, int col, string file, string format, params object[] args) : this(line, col, file, string.Format(format, args))
		{
		}
		
		public ParserException(int line, int col, string file, string message, Exception inner) : base(string.Format("{0} at line {1} col {2}{3}", message, line, col, file != null ? (" in " + file) : "."), inner)
		{
		}
		
		[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
		private ParserException(SerializationInfo info, StreamingContext context) : base(info, context)
		{
		}
	}
	
	// Thread safe if Parser instances are not shared across threads.
	internal sealed partial class ExpressionParser
	{
		public ExpressionParser()
		{
			m_nonterminals.Add("BooleanLiteral", new ParseMethod[]{this.DoParseBooleanLiteral1Rule, this.DoParseBooleanLiteral2Rule});
			m_nonterminals.Add("CharacterLiteral", new ParseMethod[]{this.DoParseCharacterLiteral1Rule, this.DoParseCharacterLiteral2Rule, this.DoParseCharacterLiteral3Rule});
			m_nonterminals.Add("ConditionalAndExpression", new ParseMethod[]{this.DoParseConditionalAndExpressionRule});
			m_nonterminals.Add("ConditionalOrExpression", new ParseMethod[]{this.DoParseConditionalOrExpressionRule});
			m_nonterminals.Add("Digit", new ParseMethod[]{this.DoParseDigitRule});
			m_nonterminals.Add("ExclusiveOrExpression", new ParseMethod[]{this.DoParseExclusiveOrExpressionRule});
			m_nonterminals.Add("Exponent", new ParseMethod[]{this.DoParseExponentRule});
			m_nonterminals.Add("HexDigit", new ParseMethod[]{this.DoParseHexDigitRule});
			m_nonterminals.Add("Identifier", new ParseMethod[]{this.DoParseIdentifierRule});
			m_nonterminals.Add("IdentifierPart", new ParseMethod[]{this.DoParseIdentifierPartRule});
			m_nonterminals.Add("IdentifierStart", new ParseMethod[]{this.DoParseIdentifierStart1Rule, this.DoParseIdentifierStart2Rule, this.DoParseIdentifierStart3Rule, this.DoParseIdentifierStart4Rule, this.DoParseIdentifierStart5Rule});
			m_nonterminals.Add("Integer", new ParseMethod[]{this.DoParseInteger1Rule, this.DoParseInteger2Rule, this.DoParseInteger3Rule});
			m_nonterminals.Add("IntegerLiteral", new ParseMethod[]{this.DoParseIntegerLiteralRule});
			m_nonterminals.Add("IntSuffix", new ParseMethod[]{this.DoParseIntSuffixRule});
			m_nonterminals.Add("Letter", new ParseMethod[]{this.DoParseLetterRule});
			m_nonterminals.Add("Literal", new ParseMethod[]{this.DoParseLiteralRule});
			m_nonterminals.Add("MemberAccess", new ParseMethod[]{this.DoParseMemberAccessRule});
			m_nonterminals.Add("NullLiteral", new ParseMethod[]{this.DoParseNullLiteralRule});
			m_nonterminals.Add("PrimaryExpression", new ParseMethod[]{this.DoParsePrimaryExpressionRule});
			m_nonterminals.Add("RealLiteral", new ParseMethod[]{this.DoParseRealLiteral1Rule, this.DoParseRealLiteral2Rule, this.DoParseRealLiteral3Rule, this.DoParseRealLiteral4Rule});
			m_nonterminals.Add("RealSuffix", new ParseMethod[]{this.DoParseRealSuffixRule});
			m_nonterminals.Add("RelationalExpression", new ParseMethod[]{this.DoParseRelationalExpression1Rule, this.DoParseRelationalExpression2Rule});
			m_nonterminals.Add("RelationalOp", new ParseMethod[]{this.DoParseRelationalOpRule});
			m_nonterminals.Add("S", new ParseMethod[]{this.DoParseSRule});
			m_nonterminals.Add("Sign", new ParseMethod[]{this.DoParseSignRule});
			m_nonterminals.Add("Space", new ParseMethod[]{this.DoParseSpaceRule});
			m_nonterminals.Add("StringLiteral", new ParseMethod[]{this.DoParseStringLiteral1Rule, this.DoParseStringLiteral2Rule});
			m_nonterminals.Add("StringCharacter", new ParseMethod[]{this.DoParseStringCharacter1Rule, this.DoParseStringCharacter2Rule});
			m_nonterminals.Add("UnaryExpression", new ParseMethod[]{this.DoParseUnaryExpression1Rule, this.DoParseUnaryExpression2Rule});
			m_nonterminals.Add("VerbatimStringCharacter", new ParseMethod[]{this.DoParseVerbatimStringCharacter1Rule, this.DoParseVerbatimStringCharacter2Rule});
			OnCtorEpilog();
		}
		
		public Expression Parse(string input)
		{
			return DoParseFile(input, null);
		}
		
		// File is used for error reporting.
		public Expression Parse(string input, string file)
		{
			return DoParseFile(input, file);
		}
		
		#region Non-Terminal Parse Methods
		// BooleanLiteral := ('true' / 'True') S
		private State DoParseBooleanLiteral1Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "true");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "True");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				value = new Literal<bool>(true);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// BooleanLiteral := ('false' / 'False') S
		private State DoParseBooleanLiteral2Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoChoice(s, r,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "false");},
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "False");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				value = new Literal<bool>(false);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// CharacterLiteral := '\'' '\\' ['\"\\0abfbrtv] '\'' S
		private State DoParseCharacterLiteral1Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\'");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\\");},
			delegate (State s, List<Result> r) {return DoParseRange(s, r, false, "'\"\\0abfbrtv", string.Empty, null, "['\"\\0abfbrtv]");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\'");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
				string s = text; value = DoParseEscapeChar(s[2]);
				if (text != null)
					_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// CharacterLiteral := '\'' '\\x' HexDigit+ '\'' S
		private State DoParseCharacterLiteral2Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\'");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\\x");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "HexDigit");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\'");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
				value = DoParseHexEscapeChar(text.Trim());
				if (text != null)
					_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// CharacterLiteral := '\'' [^'\\\n] '\'' S
		private State DoParseCharacterLiteral3Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\'");},
			delegate (State s, List<Result> r) {return DoParseRange(s, r, true, "'\\\n", string.Empty, null, "[^'\\\n]");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\'");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
				string s = text; value = new Literal<char>(s[1]);
				if (text != null)
					_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// ConditionalAndExpression := ExclusiveOrExpression ('&&' S ExclusiveOrExpression)*
		private State DoParseConditionalAndExpressionRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "ExclusiveOrExpression");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "&&");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "ExclusiveOrExpression");});});});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				value = DoEvalAndExpr(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// ConditionalOrExpression := ConditionalAndExpression ('||' S ConditionalAndExpression)*
		private State DoParseConditionalOrExpressionRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "ConditionalAndExpression");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "||");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "ConditionalAndExpression");});});});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				value = DoEvalOrExpr(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Digit := [0-9]
		private State DoParseDigitRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoParseRange(_state, results, false, string.Empty, "09", null, "[0-9]");
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// ExclusiveOrExpression := RelationalExpression ('^' S RelationalExpression)*
		private State DoParseExclusiveOrExpressionRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "RelationalExpression");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, "^");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "RelationalExpression");});});});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				value = DoEvalExclusiveOrExpr(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Exponent := [eE] Sign? Digit+
		private State DoParseExponentRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseRange(s, r, false, "eE", string.Empty, null, "[eE]");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Sign");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Digit");});});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// HexDigit := [0-9a-fA-F]
		private State DoParseHexDigitRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoParseRange(_state, results, false, string.Empty, "09afAF", null, "[0-9a-fA-F]");
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Identifier := IdentifierStart IdentifierPart* S
		private State DoParseIdentifierRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "IdentifierStart");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "IdentifierPart");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
				value = new Identifier(text.Trim());
				if (text != null)
					_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "identifier";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// IdentifierPart := Letter / '_'
		private State DoParseIdentifierPartRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Letter");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "_");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// IdentifierStart := Letter
		private State DoParseIdentifierStart1Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoParse(_state, results, "Letter");
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// IdentifierStart := Digit
		private State DoParseIdentifierStart2Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoParse(_state, results, "Digit");
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// IdentifierStart := [\\cPc]
		private State DoParseIdentifierStart3Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoParseRange(_state, results, false, string.Empty, string.Empty, new UnicodeCategory[]{UnicodeCategory.ConnectorPunctuation}, "[\\cPc]");
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// IdentifierStart := [\\cMn\\cMc]
		private State DoParseIdentifierStart4Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoParseRange(_state, results, false, string.Empty, string.Empty, new UnicodeCategory[]{UnicodeCategory.NonSpacingMark, UnicodeCategory.SpacingCombiningMark}, "[\\cMn\\cMc]");
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// IdentifierStart := [\\cCf]
		private State DoParseIdentifierStart5Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoParseRange(_state, results, false, string.Empty, string.Empty, new UnicodeCategory[]{UnicodeCategory.Format}, "[\\cCf]");
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Integer := '\\x' HexDigit+
		private State DoParseInteger1Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\\x");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "HexDigit");});});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
				value = new Literal<ulong>(ulong.Parse(text.Substring(2), NumberStyles.AllowHexSpecifier));
				if (text != null)
					_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Integer := '-' Digit+
		private State DoParseInteger2Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "-");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Digit");});});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
				value = new Literal<long>(long.Parse(text));
				if (text != null)
					_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Integer := '+'? Digit+
		private State DoParseInteger3Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParseLiteral(s2, r2, "+");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Digit");});});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
				value = new Literal<ulong>(ulong.Parse(text));
				if (text != null)
					_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// IntegerLiteral := Integer IntSuffix? S
		private State DoParseIntegerLiteralRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Integer");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "IntSuffix");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// IntSuffix := 'UL' / 'Ul' / 'uL' / 'ul' / 'LU' / 'Lu' / 'lU' / 'lu' / 'U' / 'u' / 'L' / 'l'
		private State DoParseIntSuffixRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "UL");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "Ul");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "uL");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "ul");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "LU");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "Lu");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "lU");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "lu");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "U");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "u");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "L");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "l");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Letter := [\\cLu\\cLl\\cLt\\cLm\\cLo\\cNl]
		private State DoParseLetterRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoParseRange(_state, results, false, string.Empty, string.Empty, new UnicodeCategory[]{UnicodeCategory.UppercaseLetter, UnicodeCategory.LowercaseLetter, UnicodeCategory.TitlecaseLetter, UnicodeCategory.ModifierLetter, UnicodeCategory.OtherLetter, UnicodeCategory.LetterNumber}, "[\\cLu\\cLl\\cLt\\cLm\\cLo\\cNl]");
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Literal := BooleanLiteral / RealLiteral / IntegerLiteral / CharacterLiteral / StringLiteral / NullLiteral
		private State DoParseLiteralRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "BooleanLiteral");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "RealLiteral");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "IntegerLiteral");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "CharacterLiteral");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "StringLiteral");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "NullLiteral");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// MemberAccess := Identifier ('.' S Identifier)+
		private State DoParseMemberAccessRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoSequence(s2, r2,
					delegate (State s3, List<Result> r3) {return DoParseLiteral(s3, r3, ".");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "S");},
					delegate (State s3, List<Result> r3) {return DoParse(s3, r3, "Identifier");});});});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				value = DoEvalMemberAccessExpr(results);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// NullLiteral := 'null' S
		private State DoParseNullLiteralRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "null");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				value = new Literal<object>(null);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// PrimaryExpression := Literal / MemberAccess / Identifier
		private State DoParsePrimaryExpressionRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Literal");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "MemberAccess");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Identifier");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// RealLiteral := Sign? Digit+ '.' Digit+ Exponent? RealSuffix? S
		private State DoParseRealLiteral1Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Sign");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Digit");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ".");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Digit");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Exponent");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "RealSuffix");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
				value = DoParseReal(text.Trim());
				if (text != null)
					_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// RealLiteral := Sign? '.' Digit+ Exponent? RealSuffix? S
		private State DoParseRealLiteral2Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Sign");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ".");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Digit");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Exponent");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "RealSuffix");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
				value = DoParseReal(text.Trim());
				if (text != null)
					_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// RealLiteral := Sign? Digit+ Exponent RealSuffix? S
		private State DoParseRealLiteral3Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Sign");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Digit");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "Exponent");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "RealSuffix");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
				value = DoParseReal(text.Trim());
				if (text != null)
					_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// RealLiteral := Sign? Digit+ RealSuffix S
		private State DoParseRealLiteral4Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 1,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Sign");});},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 1, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "Digit");});},
			delegate (State s, List<Result> r) {return DoParse(s, r, "RealSuffix");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
				value = DoParseReal(text.Trim());
				if (text != null)
					_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// RealSuffix := [fFdDmM]
		private State DoParseRealSuffixRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoParseRange(_state, results, false, "fFdDmM", string.Empty, null, "[fFdDmM]");
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// RelationalExpression := UnaryExpression RelationalOp S UnaryExpression
		private State DoParseRelationalExpression1Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParse(s, r, "UnaryExpression");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "RelationalOp");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "UnaryExpression");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				value = new RelationalExpression(results[0].Value, results[2].Value, results[1].Text);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// RelationalExpression := UnaryExpression
		private State DoParseRelationalExpression2Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoParse(_state, results, "UnaryExpression");
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// RelationalOp := '<=' / '<' / '>=' / '>' / '==' / '!='
		private State DoParseRelationalOpRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoChoice(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "<=");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "<");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ">=");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, ">");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "==");},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "!=");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// S := Space*
		private State DoParseSRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoRepetition(_state, results, 0, 2147483647,
			delegate (State s, List<Result> r) {return DoParse(s, r, "Space");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
				text = null;
				if (text != null)
					_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Sign := [+-]
		private State DoParseSignRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoParseRange(_state, results, false, "+-", string.Empty, null, "[+-]");
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// Space := [ \t\r\n]
		private State DoParseSpaceRule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoParseRange(_state, results, false, " \t\r\n", string.Empty, null, "[ \t\r\n]");
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			else
			{
				string expected = null;
				expected = "whitespace";
				if (expected != null)
					_state = new State(_start.Index, false, ErrorSet.Combine(_start.Errors, new ErrorSet(_state.Errors.Index, expected)));
			}
			
			return _state;
		}
		
		// StringLiteral := '@"' VerbatimStringCharacter* '"' S
		private State DoParseStringLiteral1Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "@\"");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "VerbatimStringCharacter");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
				value = DoParseVerbatimString(text.Trim());
				if (text != null)
					_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// StringLiteral := '"' StringCharacter* '"' S
		private State DoParseStringLiteral2Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");},
			delegate (State s, List<Result> r) {return DoRepetition(s, r, 0, 2147483647,
				delegate (State s2, List<Result> r2) {return DoParse(s2, r2, "StringCharacter");});},
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\"");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				string text = m_input.Substring(_start.Index, _state.Index - _start.Index);
				value = DoParseString(text.Trim());
				if (text != null)
					_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// StringCharacter := '\\' .
		private State DoParseStringCharacter1Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "\\");},
			delegate (State s, List<Result> r) {return DoParseRange(s, r, false, string.Empty, "\x0001\xFFFF", null, ".");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// StringCharacter := [^\n\"]
		private State DoParseStringCharacter2Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoParseRange(_state, results, true, "\n\"", string.Empty, null, "[^\n\"]");
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// UnaryExpression := '!' S PrimaryExpression
		private State DoParseUnaryExpression1Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoSequence(_state, results,
			delegate (State s, List<Result> r) {return DoParseLiteral(s, r, "!");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "S");},
			delegate (State s, List<Result> r) {return DoParse(s, r, "PrimaryExpression");});
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				value = new NotExpression(results[1].Value);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// UnaryExpression := PrimaryExpression
		private State DoParseUnaryExpression2Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoParse(_state, results, "PrimaryExpression");
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// VerbatimStringCharacter := '""'
		private State DoParseVerbatimStringCharacter1Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoParseLiteral(_state, results, "\"\"");
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		
		// VerbatimStringCharacter := [^\"]
		private State DoParseVerbatimStringCharacter2Rule(State _state, List<Result> _outResults)
		{
			State _start = _state;
			List<Result> results = new List<Result>();
			
			_state = DoParseRange(_state, results, true, "\"", string.Empty, null, "[^\"]");
			
			if (_state.Parsed)
			{
				Expression value = results.Count > 0 ? results[0].Value : default(Expression);
				_outResults.Add(new Result(this, _start.Index, _state.Index - _start.Index, m_input, value));
			}
			
			return _state;
		}
		#endregion
		
		#region Private Helper Methods
		partial void OnCtorEpilog();
		partial void OnParseProlog();
		partial void OnParseEpilog(State state);
		
		private Expression DoParseFile(string input, string file)
		{
			m_file = file;
			m_input = m_file;				// we need to ensure that m_file is used or we will (in some cases) get a compiler warning
			m_input = input + "\x0";	// add a sentinel so we can avoid range checks
			m_cache.Clear();
			
			State state = new State(0, true);
			List<Result> results = new List<Result>();
			
			OnParseProlog();
			state = DoParse(state, results, "ConditionalOrExpression");
			
			int i = state.Index;
			if (!state.Parsed)
				DoThrow(state.Errors.Index, state.Errors.ToString());
			else if (i < input.Length)
				if (state.Errors.Expected.Length > 0)
					DoThrow(state.Errors.Index, state.Errors.ToString());
				else
					DoThrow(state.Errors.Index, "Not all input was consumed starting from '" + input.Substring(i, Math.Min(16, input.Length - i)) + "'");
			OnParseEpilog(state);
			
			return results[0].Value;
		}
		
		public string DoEscapeAll(string s)
		{
			System.Text.StringBuilder builder = new System.Text.StringBuilder(s.Length);
			
			foreach (char ch in s)
			{
				if (ch == '\n')
					builder.Append("\\n");
				
				else if (ch == '\r')
					builder.Append("\\r");
				
				else if (ch == '\t')
					builder.Append("\\t");
				
				else if (ch < ' ')
					builder.AppendFormat("\\x{0:X2}", (int) ch);
				
				else
					builder.Append(ch);
			}
			
			return builder.ToString();
		}
		
		// This is normally only used for error handling so it doesn't need to be too
		// fast. If it somehow does become a bottleneck for some parsers they can
		// replace it with the custom-methods setting.
		private int DoGetLine(int index)
		{
			int line = 1;
			
			int i = 0;
			while (i <= index)
			{
				char ch = m_input[i++];
				
				if (ch == '\r' && m_input[i] == '\n')
				{
					++i;
					++line;
				}
				else if (ch == '\r')
				{
					++line;
				}
				else if (ch == '\n')
				{
					++line;
				}
			}
			
			return line;
		}
		
		private int DoGetCol(int index)
		{
			int start = index;
			
			while (index > 0 && m_input[index - 1] != '\n' && m_input[index - 1] != '\r')
			{
				--index;
			}
			
			return start - index + 1;
		}
		
		private void DoThrow(int index, string format, params object[] args)
		{
			int line = DoGetLine(index);
			int col = DoGetCol(index);
		
			// We need this retarded if or string.Format will throw an error if it
			// gets a format string like "Expected { or something".
			if (args != null && args.Length > 0)
				throw new ParserException(line, col, m_file, DoEscapeAll(string.Format(format, args)));
			else
				throw new ParserException(line, col, m_file, DoEscapeAll(format));
		}
		
		private State DoParseLiteral(State state, List<Result> results, string literal)
		{
			int j = state.Index;
			
			for (int i = 0; i < literal.Length; ++i)
			{
				if (m_input[j + i] != literal[i])
				{
					return new State(state.Index, false, ErrorSet.Combine(state.Errors, new ErrorSet(state.Index, literal)));
				}
			}
			
			int k = j + literal.Length;
			
			results.Add(new Result(this, j, literal.Length, m_input, default(Expression)));
			state = new State(k, true, state.Errors);
			
			return state;
		}
		
		private State DoParse(State state, List<Result> results, string nonterminal)
		{
			State start = state;
			
			CacheValue cache;
			CacheKey key = new CacheKey(nonterminal, start.Index);
			if (!m_cache.TryGetValue(key, out cache))
			{
				ParseMethod[] methods = m_nonterminals[nonterminal];
				
				int oldCount = results.Count;
				state = DoChoice(state, results, methods);
				
				bool hasResult = state.Parsed && results.Count > oldCount;
				Expression value = hasResult ? results[results.Count - 1].Value : default(Expression);
				cache = new CacheValue(state, value, hasResult);
				m_cache.Add(key, cache);
			}
			else
			{
				if (cache.HasResult)
					results.Add(new Result(this, start.Index, cache.State.Index - start.Index, m_input, cache.Value));
			}
			
			return cache.State;
		}
		
		private State DoChoice(State state, List<Result> results, params ParseMethod[] methods)
		{
			State start = state;
			int startResult = results.Count;
			
			foreach (ParseMethod method in methods)
			{
				State temp = method(state, results);
				if (temp.Parsed)
				{
					state = temp;
					break;
				}
				else
				{
					state = new State(start.Index, false, ErrorSet.Combine(state.Errors, temp.Errors));
					results.RemoveRange(startResult, results.Count - startResult);
				}
			}
			
			return state;
		}
		
		private State DoSequence(State state, List<Result> results, params ParseMethod[] methods)
		{
			State start = state;
			int startResult = results.Count;
			
			foreach (ParseMethod method in methods)
			{
				State temp = method(state, results);
				if (temp.Parsed)
				{
					state = temp;
				}
				else
				{
					state = new State(start.Index, false, ErrorSet.Combine(start.Errors, temp.Errors));
					results.RemoveRange(startResult, results.Count - startResult);
					break;
				}
			}
			
			return state;
		}
		
		private State DoRepetition(State state, List<Result> results, int min, int max, ParseMethod method)
		{
			State start = state;
			
			int count = 0;
			while (count <= max)
			{
				State temp = method(state, results);
				if (temp.Parsed && temp.Index > state.Index)
				{
					state = temp;
					++count;
				}
				else
				{
					state = new State(state.Index, true, ErrorSet.Combine(state.Errors, temp.Errors));
					break;
				}
			}
			
			if (count < min || count > max)
				state = new State(start.Index, false, ErrorSet.Combine(start.Errors, state.Errors));
			
			return state;
		}
		
		private State DoParseRange(State state, List<Result> results, bool inverted, string chars, string ranges, UnicodeCategory[] categories, string label)
		{
			char ch = m_input[state.Index];
			
			bool matched = chars.IndexOf(ch) >= 0;
			for (int i = 0; i < ranges.Length && !matched; i += 2)
			{
				matched = ranges[i] <= ch && ch <= ranges[i + 1];
			}
			for (int i = 0; categories != null && i < categories.Length && !matched; ++i)
			{
				matched = char.GetUnicodeCategory(ch) == categories[i];
			}
			
			if (inverted)
				matched = !matched && ch != '\x0';
			
			if (matched)
			{
				results.Add(new Result(this, state.Index, 1, m_input, default(Expression)));
				return new State(state.Index + 1, true, state.Errors);
			}
			
			return new State(state.Index, false, ErrorSet.Combine(state.Errors, new ErrorSet(state.Index, label)));
		}
		#endregion
		
		#region Private Types
		private struct CacheKey : IEquatable<CacheKey>
		{
			public CacheKey(string rule, int index)
			{
				m_rule = rule;
				m_index = index;
			}
			
			public override bool Equals(object obj)
			{
				if (obj == null)
					return false;
				
				if (GetType() != obj.GetType())
					return false;
				
				CacheKey rhs = (CacheKey) obj;
				return this == rhs;
			}
			
			public bool Equals(CacheKey rhs)
			{
				return this == rhs;
			}
			
			public static bool operator==(CacheKey lhs, CacheKey rhs)
			{
				if (lhs.m_rule != rhs.m_rule)
					return false;
				
				if (lhs.m_index != rhs.m_index)
					return false;
				
				return true;
			}
			
			public static bool operator!=(CacheKey lhs, CacheKey rhs)
			{
				return !(lhs == rhs);
			}
			
			public override int GetHashCode()
			{
				int hash = 0;
				
				unchecked
				{
					hash += m_rule.GetHashCode();
					hash += m_index.GetHashCode();
				}
				
				return hash;
			}
			
			private string m_rule;
			private int m_index;
		}
		
		private struct CacheValue
		{
			public CacheValue(State state, Expression value, bool hasResult)
			{
				State = state;
				Value = value;
				HasResult = hasResult;
			}
			
			public State State;
			
			public Expression Value;
			
			public bool HasResult;
		}
		
		private delegate State ParseMethod(State state, List<Result> results);
		
		// These are either an error that caused parsing to fail or the reason a
		// successful parse stopped.
		private struct ErrorSet
		{
			public ErrorSet(int index, string expected)
			{
				Index = index;
				Expected = new string[]{expected};
			}
			
			public ErrorSet(int index, string[] expected)
			{
				Index = index;
				Expected = expected;
			}
			
			// The location associated with the errors. For a failed parse this will be the
			// same as State.Index. For a successful parse it will be State.Index or later.
			public int Index;
			
			// This will be the name of something which was expected, but not found.
			public string[] Expected;
			
			public static ErrorSet Combine(ErrorSet lhs, ErrorSet rhs)
			{
				if (lhs.Index > rhs.Index)
				{
					return lhs;
				}
				else if (lhs.Index < rhs.Index)
				{
					return rhs;
				}
				else
				{
					List<string> errors = new List<string>(lhs.Expected.Length + rhs.Expected.Length);
					errors.AddRange(lhs.Expected);
					foreach (string err in rhs.Expected)
					{
						if (errors.IndexOf(err) < 0)
							errors.Add(err);
					}
					return new ErrorSet(lhs.Index, errors.ToArray());
				}
			}
			
			public override string ToString()
			{
				if (Expected.Length > 0)
					return string.Format("Expected {0}", string.Join(" or ", Expected));
				else
					return "<none>";
			}
		}
		
		// The state of the parser.
		private struct State
		{
			public State(int index, bool parsed)
			{
				Index = index;
				Parsed = parsed;
				Errors = new ErrorSet(index, new string[0]);
			}
			
			public State(int index, bool parsed, ErrorSet errors)
			{
				Index = index;
				Parsed = parsed;
				Errors = errors;
			}
			
			// Index of the first unconsumed character.
			public int Index;
			
			// True if the expression associated with the state successfully parsed.
			public bool Parsed;
			
			// If Parsed is false then this will explain why. If Parsed is true it will
			// say why the parse stopped.
			public ErrorSet Errors;
		}
		
		// The result of parsing a literal or non-terminal.
		private struct Result
		{
			public Result(ExpressionParser parser, int index, int length, string input, Expression value)
			{
				m_parser = parser;
				m_index = index;
				m_length = length;
				m_input = input;
				Value = value;
			}
			
			// The text which was parsed by the terminal or non-terminal.
			public string Text {get {return m_input.Substring(m_index, m_length);}}
			
			// The 1-based line number the (non)terminal started on.
			public int Line {get {return m_parser.DoGetLine(m_index);}}
			
			// The 1-based column number the (non)terminal started on.
			public int Col {get {return m_parser.DoGetCol(m_index);}}
			
			// For non-terminals this will be the result of the semantic action, 
			// otherwise it will be the default value.
			public Expression Value;
			
			private ExpressionParser m_parser;
			private int m_index;
			private int m_length;
			private string m_input;
		}
		
		#endregion
		
		#region Fields
		private string m_input;
		private string m_file;
		private Dictionary<string, ParseMethod[]> m_nonterminals = new Dictionary<string, ParseMethod[]>();
		private Dictionary<CacheKey, CacheValue> m_cache = new Dictionary<CacheKey, CacheValue>();
		#endregion
	}
}
