# peg-sharp grammar used to parse conditional breakpoint expressions.namespace = Debuggerstart = ConditionalOrExpressionvalue = ExpressionBooleanLiteral := ('true' / 'True') S	`value = new Literal<bool>(true)`BooleanLiteral := ('false' / 'False') S	`value = new Literal<bool>(false)`CharacterLiteral := '\'' '\\' ['"\\0abfbrtv] '\'' S	`string s = text; value = DoParseEscapeChar(s[2])`	# temporary works around a bug in peg-sharpCharacterLiteral := '\'' '\\x' HexDigit+ '\'' S	`value = DoParseHexEscapeChar(text.Trim())`CharacterLiteral := '\'' [^'\\\n] '\'' S	`string s = text; value = new Literal<char>(s[1])`ConditionalAndExpression := ExclusiveOrExpression ('&&' S ExclusiveOrExpression)*	`value = DoEvalAndExpr(results)`ConditionalOrExpression := ConditionalAndExpression ('||' S ConditionalAndExpression)*	`value = DoEvalOrExpr(results)`Digit := [0-9];ExclusiveOrExpression := RelationalExpression ('^' S RelationalExpression)*	`value = DoEvalExclusiveOrExpr(results)`Exponent := [eE] Sign? Digit+;HexDigit := [0-9a-fA-F];Identifier := IdentifierStart IdentifierPart* S	`value = new Identifier(text.Trim())` `expected = "identifier"`IdentifierPart := Letter / '_';IdentifierStart := Letter;IdentifierStart := Digit;			# decimal digitIdentifierStart := [\cPc];			# connecting characterIdentifierStart := [\cMn\cMc];	# combining characterIdentifierStart := [\cCf];			# formatting characterInteger := '\\x' HexDigit+	`value = new Literal<ulong>(ulong.Parse(text.Substring(2), NumberStyles.AllowHexSpecifier))`Integer := '-' Digit+	`value = new Literal<long>(long.Parse(text))`Integer := '+'? Digit+	`value = new Literal<ulong>(ulong.Parse(text))`IntegerLiteral := Integer IntSuffix? S;IntSuffix := 'UL' / 'Ul' / 'uL' / 'ul' / 'LU' / 'Lu' / 'lU' / 'lu' / 'U' / 'u' / 'L' / 'l';Letter := [\cLu\cLl\cLt\cLm\cLo\cNl];Literal := BooleanLiteral / RealLiteral / IntegerLiteral / CharacterLiteral / StringLiteral / NullLiteral;NullLiteral := 'null' S	`value = new Literal<object>(null)`PrimaryExpression := Literal / Identifier;RealLiteral := Sign? Digit+ '.' Digit+ Exponent? RealSuffix?	 S	`value = DoParseReal(text.Trim())`RealLiteral := Sign? '.' Digit+ Exponent? RealSuffix? S	`value = DoParseReal(text.Trim())`RealLiteral := Sign? Digit+ Exponent RealSuffix? S	`value = DoParseReal(text.Trim())`RealLiteral := Sign? Digit+ RealSuffix S	`value = DoParseReal(text.Trim())`RealSuffix := [fFdDmM];RelationalExpression := UnaryExpression RelationalOp S UnaryExpression	`value = new RelationalExpression(results[0].Value, results[2].Value, results[1].Text)`RelationalExpression := UnaryExpression;RelationalOp := '<=' / '<' / '>=' / '>' / '==' / '!=';S := Space* `text = null`  # We use a separate space rule because x* always succeeds.Sign := [+-];Space := [ \t\r\n] `;` `expected = "whitespace"`StringLiteral := '@"' VerbatimStringCharacter* '"' S`value = DoParseVerbatimString(text.Trim())`StringLiteral := '"' StringCharacter* '"' S`value = DoParseString(text.Trim())`StringCharacter := '\\' .;StringCharacter := [^\n"];UnaryExpression := '!' S PrimaryExpression	`value = new NotExpression(results[1].Value)`UnaryExpression := PrimaryExpression;VerbatimStringCharacter := '""';VerbatimStringCharacter := [^"];# primary-expression:#     element-access#     member-access #     'this'#     literal#     identifier# member-access:#    predefined-type   '.'   identifier#   primary-expression   '.'   identifier		# variable, enum, or property# predefined-type:  one of#     bool     byte    char     decimal     double     float     int     long#     object   sbyte   short    string      uint       ulong     ushort# element-access:#     primary-expression   '['   primary-expression   ']'