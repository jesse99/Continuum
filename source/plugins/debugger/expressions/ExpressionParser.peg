# peg-sharp grammar used to parse conditional breakpoint expressions.namespace = Debuggerstart = ConditionalOrExpressionvalue = ExpressionBooleanLiteral := ('true' / 'True') S	`value = new Literal<bool>(true)`BooleanLiteral := ('false' / 'False') S	`value = new Literal<bool>(false)`CharacterLiteral := '\'' . '\'' S	`string s = text; value = new Literal<char>(s[1])`	# temporary works around a bug in peg-sharpConditionalAndExpression := ExclusiveOrExpression ('&&' S ExclusiveOrExpression)*	`value = DoEvalAndExpr(results)`ConditionalOrExpression := ConditionalAndExpression ('||' S ConditionalAndExpression)*	`value = DoEvalOrExpr(results)`Digit := [0-9];EqualityExpression := RelationalExpression '==' S RelationalExpression	`value = new EqualityExpression(results[0].Value, results[2].Value)`EqualityExpression := RelationalExpression '!=' S RelationalExpression	`value = new InequalityExpression(results[0].Value, results[2].Value)`EqualityExpression := RelationalExpression;ExclusiveOrExpression := EqualityExpression ('^' S EqualityExpression)*	`value = DoEvalExclusiveOrExpr(results)`Identifier := IdentifierStart IdentifierPart* S	`value = new Identifier(text.Trim())` `expected = "identifier"`IdentifierPart := Letter / '_';IdentifierStart := Letter;IdentifierStart := Digit;			# decimal digitIdentifierStart := [\cPc];			# connecting characterIdentifierStart := [\cMn\cMc];	# combining characterIdentifierStart := [\cCf];			# formatting characterIntegerLiteral := '+' S Digit+ S	`value = new Literal<int>(int.Parse(text))`IntegerLiteral := '-' S Digit+ S	`value = new Literal<int>(int.Parse(text))`IntegerLiteral := Digit+ S			`value = new Literal<int>(int.Parse(text))`Letter := [\cLu\cLl\cLt\cLm\cLo\cNl];Literal := BooleanLiteral / IntegerLiteral / CharacterLiteral;PrimaryExpression := Literal / Identifier;RelationalExpression := PrimaryExpression RelationalOp PrimaryExpression	`value = new RelationalExpression(results[0].Value, results[2].Value, results[1].Text)`RelationalExpression := PrimaryExpression;RelationalOp := ('<=' / '<' / '>=' / '>') S;S := Space* `text = null`  # We use a separate space rule because x* always succeeds.Space := [ \t\r\n] `;` `expected = "whitespace"`# primary-expression:#     element-access#     member-access #     'this'#     literal#     identifier# member-access:#    predefined-type   '.'   identifier#   primary-expression   '.'   identifier		# variable, enum, or property# predefined-type:  one of#     bool     byte    char     decimal     double     float     int     long#     object   sbyte   short    string      uint       ulong     ushort# element-access:#     primary-expression   '['   primary-expression   ']'# literal:#      boolean-literal#      real-literal#      integer-literal#      character-literal#      string-literal#      null-literal