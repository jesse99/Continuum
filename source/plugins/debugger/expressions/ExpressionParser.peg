# peg-sharp grammar used to parse conditional breakpoint expressions.namespace = Debuggerstart = RelationalExpressionvalue = ExpressionBooleanLiteral := ('true' / 'True') S	`value = new Literal<bool>(true)`BooleanLiteral := ('false' / 'False') S	`value = new Literal<bool>(false)`Identifier := IdentifierStart IdentifierPart* S	`value = new Identifier(text.Trim())` `expected = "identifier"`IdentifierPart := Letter / '_';IdentifierStart := Letter;IdentifierStart := [0-9];			# decimal digitIdentifierStart := [\cPc];			# connecting characterIdentifierStart := [\cMn\cMc];	# combining characterIdentifierStart := [\cCf];			# formatting characterLetter := [\cLu\cLl\cLt\cLm\cLo\cNl];Literal := BooleanLiteral;PrimaryExpression := Literal / Identifier;RelationalExpression := PrimaryExpression;S := Space* `text = null`  # We use a separate space rule because x* always succeeds.Space := [ \t\r\n] `;` `expected = "whitespace"`# relational-expression:#      primary-expression   <=   primary-expression#      primary-expression   >=   primary-expression#      primary-expression   <   primary-expression#      primary-expression   >   primary-expression#      primary-expression   ==   primary-expression#      primary-expression   !=   primary-expression# primary-expression:#     element-access#     member-access #     'this'#     literal#     identifier # member-access:#    predefined-type   '.'   identifier#   primary-expression   '.'   identifier		# variable, enum, or property# predefined-type:  one of#     bool     byte    char     decimal     double     float     int     long#     object   sbyte   short    string      uint       ulong     ushort# element-access:#     primary-expression   '['   primary-expression   ']'# literal:#      boolean-literal#      real-literal#      integer-literal#      character-literal#      string-literal#      null-literal