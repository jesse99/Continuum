# peg-sharp grammar used to parse conditional breakpoint expressions.namespace = Debuggerstart = ConditionalOrExpressionvalue = ExpressionBooleanLiteral := ('true' / 'True') S	`value = new Literal<bool>(true)`BooleanLiteral := ('false' / 'False') S	`value = new Literal<bool>(false)`CharacterLiteral := '\'' . '\'' S	`string s = text; value = new Literal<char>(s[1])`	# temporary works around a bug in peg-sharpConditionalAndExpression := ExclusiveOrExpression ('&&' S ExclusiveOrExpression)*	`value = DoEvalAndExpr(results)`ConditionalOrExpression := ConditionalAndExpression ('||' S ConditionalAndExpression)*	`value = DoEvalOrExpr(results)`Digit := [0-9];ExclusiveOrExpression := RelationalExpression ('^' S RelationalExpression)*	`value = DoEvalExclusiveOrExpr(results)`Identifier := IdentifierStart IdentifierPart* S	`value = new Identifier(text.Trim())` `expected = "identifier"`IdentifierPart := Letter / '_';IdentifierStart := Letter;IdentifierStart := Digit;			# decimal digitIdentifierStart := [\cPc];			# connecting characterIdentifierStart := [\cMn\cMc];	# combining characterIdentifierStart := [\cCf];			# formatting characterIntegerLiteral := '+' S Digit+ S	`value = new Literal<int>(int.Parse(text))`IntegerLiteral := '-' S Digit+ S	`value = new Literal<int>(int.Parse(text))`IntegerLiteral := Digit+ S			`value = new Literal<int>(int.Parse(text))`Letter := [\cLu\cLl\cLt\cLm\cLo\cNl];Literal := BooleanLiteral / IntegerLiteral / CharacterLiteral;PrimaryExpression := Literal / Identifier;RelationalExpression := UnaryExpression RelationalOp UnaryExpression	`value = new RelationalExpression(results[0].Value, results[2].Value, results[1].Text)`RelationalExpression := UnaryExpression;RelationalOp := ('<=' / '<' / '>=' / '>' / '==' / '!=') S;S := Space* `text = null`  # We use a separate space rule because x* always succeeds.Space := [ \t\r\n] `;` `expected = "whitespace"`UnaryExpression := '!' S PrimaryExpression	`value = new NotExpression(results[1].Value)`UnaryExpression := PrimaryExpression;# primary-expression:#     element-access#     member-access #     'this'#     literal#     identifier# member-access:#    predefined-type   '.'   identifier#   primary-expression   '.'   identifier		# variable, enum, or property# predefined-type:  one of#     bool     byte    char     decimal     double     float     int     long#     object   sbyte   short    string      uint       ulong     ushort# element-access:#     primary-expression   '['   primary-expression   ']'# literal:#      boolean-literal#      real-literal#      integer-literal#      character-literal#      string-literal#      null-literal